<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    
    <title>God in the Deep</title>
    
    <style>* { padding: 0; margin: 0;}</style>
    
<script src="//cdn.jsdelivr.net/npm/phaser@3.18.1/dist/phaser.min.js"></script>
<script src="levels.js"></script>
<script src="heroines.js"></script>
<script src="enemies.js"></script>
<script src="random.js"></script>
<script src="gui.js"></script>

</head>

<body style="background-color:#0C0E11; text-align:center;">
	
<script>
	
    console.log("Version 0.2");
    
////////////// configurations Variable, mit der das Spiel gestartet wird  ////////////////////////////////////////////////////////////////////////////
    
	var config = {
		type: Phaser.AUTO,
		width: 1920,
		height: 1080,
		physics: {
			default: 'arcade',
			arcade: {
				gravity: { y: 0 },
				debug: false
			}
        },
        scale: { mode: Phaser.Scale.FIT },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
	};
    
////////////// Variablen, die in der App verwendet werden   //////////////////////////////////////////////////////////////////////////////////////////
    
    var game = new Phaser.Game(config);
    var objects = {};
    var tileArray = [];
    var matrixWidth = 25;
    var matrixHeight = 40;
    var movementTweenBarb, movementTweenMage, movementTweenRogue;
    
    var doorButton, moveButton, attackButton, searchButton,
        faceButton, specialButton, cancelButton;
    var enemyHealthBase, enemyHealthBar;
    var textBackButton, textNextButton, textNewButton;
    
    var mapImg;
    var crystal1Img, idol1Img, circle1Img;
    var door1Img, door2Img, door4Img, door5Img, door6Img;
    var trap1Sprt;
    var swirl1, swirl2;
    
    var mage, rogue, barb;
    var rangedDamage = [0];
    var eventReminder = {e2:false, e4:false};
    
    var figuresOnMap = [];
    var Info1, InfoName, Info2, Info3;
    var textHistory = [];
    var textHistoryIndex = -1;
    var gameModeIcon;
    var gameModeText;
    var xp = 0;
    var xpIcon;
    var xpText;
    
    var level = 1;
    var fightmode = false;
    
    // Funktion die alle Bilder lädt
    function preload() {
        this.load.image('map-lvl-1', 'img/map-lvl-1.png');
        this.load.image('crystal1', 'img/crystal1.png');
        this.load.image('door1', 'img/door1.png');
        this.load.image('door2', 'img/door2.png');
        this.load.image('door4', 'img/door4.png');
        this.load.image('door5', 'img/door5.png');
        this.load.image('door6', 'img/door6.png');
        this.load.image('circle1', 'img/circle1.png');
        this.load.image('idol1', 'img/idol1.png');
        this.load.image('gui', 'img/GUI.png');
        this.load.spritesheet('trap1Sprite', 'img/trap1.png', { frameWidth: 79, frameHeight: 78 });
        
        this.load.spritesheet('tileSprite', 'img/tileSprite.png', { frameWidth: 26, frameHeight: 26 });
        
        this.load.spritesheet('mageSprite', 'img/mToken.png', { frameWidth: 26, frameHeight: 26 });
        this.load.spritesheet('rogueSprite', 'img/rToken.png', { frameWidth: 26, frameHeight: 26 });
        this.load.spritesheet('barbSprite', 'img/bToken.png', { frameWidth: 26, frameHeight: 26 });
        this.load.spritesheet('e1Sprite', 'img/e1Token.png', { frameWidth: 26, frameHeight: 26 });
        this.load.spritesheet('e2Sprite', 'img/e2Token.png', { frameWidth: 26, frameHeight: 26 });
        this.load.spritesheet('e3Sprite', 'img/e3Token.png', { frameWidth: 26, frameHeight: 26 });
        this.load.spritesheet('e4Sprite', 'img/e4Token.png', { frameWidth: 26, frameHeight: 26 });
        this.load.spritesheet('swirSprite', 'img/swirl.png', { frameWidth: 52, frameHeight: 52 });
        
        this.load.spritesheet('doorSprite', 'img/door.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('moveSprite', 'img/move.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('attackSprite', 'img/attack.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('searchSprite', 'img/search.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('cancelSprite', 'img/cancel.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('specialSprite', 'img/special.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('faceSprite', 'img/face.png', { frameWidth: 86, frameHeight: 85 });
        this.load.spritesheet('enemyHealthSprite', 'img/enemyHealthBar.png', { frameWidth: 101, frameHeight: 101 });
        this.load.spritesheet('textBackSprite', 'img/textBack.png', { frameWidth: 84, frameHeight: 46 });
        this.load.spritesheet('textForwardSprite', 'img/textForward.png', { frameWidth: 84, frameHeight: 46 });
        this.load.spritesheet('textNewSprite', 'img/textNew.png', { frameWidth: 84, frameHeight: 46 });
        this.load.spritesheet('gameModeSprite', 'img/mode.png', { frameWidth: 86, frameHeight: 86 });
        this.load.spritesheet('xpSprite', 'img/xp.png', { frameWidth: 86, frameHeight: 86 });
        
	}

    // Funktion die alle Sachen erstellt
	function create() {
		objects.camera = this.cameras.add(0, 0, 1920, 1080);
		objects.camera.setBackgroundColor('#0C0E11');
        guiBuilder(this); // Greift auf gui.js zu und erstellt viele der User Interface Elemente
        
		mapImg = this.add.image(412, 540, 'map-lvl-1').setAlpha(1);
        crystal1Img = this.add.image(620, 137, 'crystal1').setAlpha(0.1);
        door1Img = this.add.image(516, 358, 'door1').setAlpha(0);
        door2Img = this.add.image(516, 618, 'door2').setAlpha(0);
        door4Img = this.add.image(607, 540, 'door4').setAlpha(0);
        door5Img = this.add.image(451, 410, 'door5').setAlpha(0);
        door6Img = this.add.image(581, 410, 'door6').setAlpha(1);
        idol1Img = this.add.image(516, 995, 'idol1').setAlpha(0);
        trap1Sprt = this.add.sprite(438, 501, 'trap1Sprite').setAlpha(0);
        circle1Img = this.add.image(230, 800, 'circle1').setAlpha(0);
		
		let index = 0;
		for (var yPos = 0; yPos < matrixHeight; yPos++ ) {
			for (var xPos = 0; xPos < matrixWidth; xPos++ ) {
                var tile = this.add.sprite(xPos*26+100, yPos*26+33, 'tileSprite');
				tile.state = 0;
                tile.name = index++;
                tile.info = 1;
				tile.walkable = [1,1,1,1,1,1,1,1];
				tile.updateState = function () {
                    if (this.state == 0) { // normaler Boden
                        this.weight = 1;
						//this.walkable = [1,1,1,1,1,1,1,1];
					} else if (this.state == "0t1") { // Trap
						this.weight = 1;
						//this.walkable = [1,1,1,1,1,1,1,1];
					} else if (this.state == "0dc") { // Türe geschlossen
						this.weight = 1;
					} else if (this.state == "0do") { // Türe offen
						this.weight = 1;
					} else if (this.state == 5) { // Wand
						//this.walkable = [0,0,0,0,0,0,0,0];
					} else if (this.state == 6) { // Schwieriges Terrain
						//this.walkable = [2,2,2,2,2,2,2,2];
						this.weight = 2;
					} else if (this.state == 7) { // Wasser
						//this.walkable = [3,3,3,3,3,3,3,3];
						this.weight = 3;
					} else if (this.state == 8) { // Niedriges Wasser
						//this.walkable = [2,2,2,2,2,2,2,2];
						this.weight = 2;
					};
				};
				tile.setInteractive();
				tile.on("pointerup", function pointerUp () {
                    // nichts ist auf der Tile und diese ist von einer Seite aus begehbar
					if (this.occupiedBy != "idol" && (this.walkable.indexOf(1) > -1 || this.walkable.indexOf(2) > -1 || this.walkable.indexOf(3) > -1) && moveButton.mode == "planning") {
                        let activeChar = figuresOnMap.findIndex(findActiveChar);
                        calculatePath(figuresOnMap[activeChar], this.name);
                        for (var i = 0; i < tileArray.length; i++) {
                            tileArray[i].setFrame(0);
                        }
                    } else if (moveButton.mode == "planning") {
                        let activeChar = figuresOnMap.findIndex(findActiveChar);
                        showText ("", figuresOnMap[activeChar], textL1[17]);
                        for (var i = 0; i < tileArray.length; i++) {
                            tileArray[i].setFrame(0);
                        }
                    }
                    if (searchButton.mode == "planning") {
                        console.log(this.name + " - x: " + this.x + " - y: " + this.y);
                        let activeChar = figuresOnMap[figuresOnMap.findIndex(findActiveChar)];
                        if (lineOfSight (activeChar, this.name) == true) {
                            showText(textL1[this.info]);
                            if (this.info == 3 && crystal1Img.alpha != 0) {
                                crystal1Img.setAlpha(1);
                                tileArray[120].state = "7e9";
                                showText(textL1[this.info], activeChar, textL1[4]);
                            } else if (this.info == 3 && crystal1Img.alpha == 0) {
                                showText(textL1[30], activeChar, textL1[31]);
                            } else if (this.info == 7) {
                                showText(textL1[this.info]);
                                trap1Sprt.setAlpha(1);
                            } else {
                                showText(textL1[this.info]);
                            }
                        } else {
                            showText("", activeChar, textL1[1]);
                        }
                        returnCursorToNormal();
                        showActions(activeChar);
                    } else if (attackButton.mode == "planning cc" && this.occupiedBy == "idol") {
                        this.checkForNeighbors();
                        let activeChar = figuresOnMap[figuresOnMap.findIndex(findActiveChar)];
                        for (let i = 0; i < this.neighbors.length; i++) {
                            if (this.neighbors[i].name == activeChar.onTile) {
                                eventDispatch (activeChar, "e7");
                            }
                        }
                        this.neighbors.length = 0;
                        returnCursorToNormal();
                        showActions(activeChar);
                    } else if (attackButton.mode == "planning rc" && this.occupiedBy == "idol") {
                        let activeChar = figuresOnMap[figuresOnMap.findIndex(findActiveChar)];
                        if (lineOfSight (activeChar, this.name) == true) {
                            eventDispatch (activeChar, "e7");
                        }
                        returnCursorToNormal();
                        showActions(activeChar);
                    }
				});
                tile.on("pointerover", function pointerOver () {
                    if (this.occupiedBy != "idol" && (this.walkable.indexOf(1) > -1 || this.walkable.indexOf(2) > -1 || this.walkable.indexOf(3) > -1) && moveButton.mode == "planning" && fightmode == true) {
                        let startTile = figuresOnMap[figuresOnMap.findIndex(findActiveChar)].onTile;
                        let pathHighlight = showPath(startTile, this.name);
                        for (var i = 0; i < pathHighlight.length; i++) {
                            tileArray[pathHighlight[i]].setFrame(1);
                        }
                    }
                });
                tile.on("pointerout", function pointerOut () {
                    if (moveButton.mode == "planning") {
                        for (var i = 0; i < tileArray.length; i++) {
                            tileArray[i].setFrame(0);
                        }
                    }
                });
				tile.neighbors = [];
				tile.neighborsDistance = [];
				tile.checkForNeighbors = function () {
					if (this.name-matrixWidth >= 0 && this.name%matrixWidth != 0 && tileArray[this.name-1-matrixWidth].walkable[4] != 0) {
						this.neighbors.push(tileArray[this.name-1-matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name-1-matrixWidth].walkable[4]);
					};
					if (this.name-matrixWidth >= 0 && tileArray[this.name-matrixWidth].walkable[5] != 0) {
						this.neighbors.push(tileArray[this.name-matrixWidth]);
						this.neighborsDistance.push(1*tileArray[this.name-matrixWidth].walkable[5]);
					};
					if (this.name-matrixWidth >= 0 && this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name-matrixWidth+1].walkable[6] != 0) {
						this.neighbors.push(tileArray[this.name-matrixWidth+1]);
						this.neighborsDistance.push(1.5*tileArray[this.name-matrixWidth+1].walkable[6]);
					};
					if (this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name+1].walkable[7] != 0) {
						this.neighbors.push(tileArray[this.name+1]);
						this.neighborsDistance.push(1*tileArray[this.name+1].walkable[7]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name+1+matrixWidth].walkable[0] != 0) {
						this.neighbors.push(tileArray[this.name+1+matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name+1+matrixWidth].walkable[0]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && tileArray[this.name+matrixWidth].walkable[1] != 0) {
						this.neighbors.push(tileArray[this.name+matrixWidth]);
						this.neighborsDistance.push(1*tileArray[this.name+matrixWidth].walkable[1]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && this.name%matrixWidth != 0 && tileArray[this.name-1+matrixWidth].walkable[2] != 0) {
						this.neighbors.push(tileArray[this.name-1+matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name-1+matrixWidth].walkable[2]);
					};
					if (this.name%matrixWidth != 0 && tileArray[this.name-1].walkable[3] != 0) {
						this.neighbors.push(tileArray[this.name-1]);
						this.neighborsDistance.push(1*tileArray[this.name-1].walkable[3]);
					};
				};
				tile.weight = 1;
				tile.estimatedWayToB = function (b) {
					
                    let a = this.name;
					
					let xDistance = (Math.abs(b%matrixWidth-a%matrixWidth));
					let yDistance = Math.abs(Math.floor(b/matrixWidth)-Math.floor(a/matrixWidth));
					let diagonals = Math.min(xDistance, yDistance);
					return xDistance + yDistance - diagonals/2;
				};
				tile.distanceTravelled;
				tile.wayPointUsefulness;
				tile.entryPoint;
                tile.occupiedBy = "";
				tileArray.push(tile);
			}
		}
        
        doorButton = this.add.sprite(400, 400, 'doorSprite').setAlpha(0);
        doorButton.setInteractive();
		doorButton.on("pointerup", function pointerUp() {
            let activeChar = figuresOnMap[figuresOnMap.findIndex(findActiveChar)];
            doors(activeChar, activeChar.onTile);
		});
        doorButton.setDepth(1);
        
        moveButton = this.add.sprite(400, 400, 'moveSprite').setAlpha(0);
        moveButton.mode = "none";
        moveButton.setInteractive();
		moveButton.on("pointerup", function pointerUp() {
            moveButton.mode = "planning";
            hideActions();
            moveButton.setAlpha(1);
            moveButton.setScale(0.5);
		});
        moveButton.setDepth(1);
        
        attackButton = this.add.sprite(400, 400, 'attackSprite').setAlpha(0);
        attackButton.mode = "none";
        attackButton.setInteractive();
		attackButton.on("pointerup", function pointerUp() {
            if (attackButton.mode == "possible rc") {
                attackButton.mode = "planning rc";
            } else {
                attackButton.mode = "planning cc";
            }
            hideActions();
            attackButton.setAlpha(1);
            attackButton.setScale(0.5);
        });
        attackButton.setDepth(1);
        
        searchButton = this.add.sprite(400, 400, 'searchSprite').setAlpha(0);
        searchButton.mode = "none";
        searchButton.setInteractive();
		searchButton.on("pointerup", function pointerUp() {
            searchButton.mode = "planning";
            hideActions();
            searchButton.setAlpha(1);
            searchButton.setScale(0.5);
		});
        searchButton.setDepth(1);
        
        specialButton = this.add.sprite(400, 400, 'specialSprite').setAlpha(0);
        specialButton.setInteractive();
        specialButton.mode = "";
		specialButton.on("pointerup", function pointerUp() {
            if (specialButton.mode == "disableTrap" && level == 1) {
                disableTrap1();
                specialButton.mode == "";
            }
		});
        specialButton.setDepth(1);
        
        faceButton = this.add.sprite(400, 400, 'faceSprite').setAlpha(0);
        faceButton.setDepth(1);
        enemyHealthBase = this.add.sprite(400, 400, 'enemyHealthSprite').setAlpha(0).setFrame(1);
        enemyHealthBar = this.add.graphics();
        enemyHealthBar.x = 0;
        enemyHealthBar.y = 0;
        enemyHealthBase.setDepth(1);
        enemyHealthBar.setDepth(1);
        
        cancelButton = this.add.sprite(400, 400, 'cancelSprite').setAlpha(0);
        cancelButton.setInteractive();
        cancelButton.on("pointerup", function pointerUp() {
            hideActions();
            deactivateFigures();
		});
        cancelButton.setDepth(1);
        
        
        // Erstellt die drei Spielfiguren
        mage = new Figure ({scene:this, x:20, y:20}, 'mageSprite');
        mage.onTile = mageStartingPosition[level];
        mage.pathToTravel.push(mageStartingPosition[level]);
        mage.dieSize = 4;
        mage.explodes = true;
        mage.health = 4;
        mage.name = "Caelith";
        mage.color = "#455059";
        mage.description = 0;
        figuresOnMap.push(mage);
        
        barb = new Figure ({scene:this, x:20, y:20}, 'barbSprite');
        barb.onTile = barbStartingPosition[level];
        barb.pathToTravel.push(barbStartingPosition[level]);
        barb.dieSize = 12;
        barb.health = 12;
        barb.name = "Rhiva";
        barb.color = "#914A23";
        barb.description = 1;
        figuresOnMap.push(barb);
        
        rogue = new Figure ({scene:this, x:20, y:20}, 'rogueSprite');
        rogue.onTile = rogueStartingPosition[level];
        rogue.pathToTravel.push(rogueStartingPosition[level]);
        rogue.dieSize = 8;
        rogue.health = 8;
        rogue.name = "Leng";
        rogue.color = "#003F5E";
        rogue.description = 2;
        figuresOnMap.push(rogue);
        
        createEnemies(this);
        buildLevel();
        
        movementTweenMage = this.tweens.add({
            targets: mage,
            x: { value: function () {
                return tileArray[mage.pathToTravel[0]].x;
            }},
            y: { value: function () { 
                return tileArray[mage.pathToTravel[0]].y;
            }},
            duration: 250,
            ease: 'Sine.easeInOut',
            onComplete: function () {
                mage.enterTile();
            },
            onCompleteScope: movementTweenMage
        });
        
        movementTweenRogue = this.tweens.add({
            targets: rogue,
            x: { value: function () {
                return tileArray[rogue.pathToTravel[0]].x;
            }},
            y: { value: function () { 
                return tileArray[rogue.pathToTravel[0]].y;
            }},
            duration: 250,
            ease: 'Sine.easeInOut',
            onComplete: function () {
                rogue.enterTile();
            },
            onCompleteScope: movementTweenRogue
        });
        
        movementTweenBarb = this.tweens.add({
            targets: barb,
            x: { value: function () {
                return tileArray[barb.pathToTravel[0]].x;
            }},
            y: { value: function () { 
                return tileArray[barb.pathToTravel[0]].y;
            }},
            duration: 250,
            ease: 'Sine.easeInOut',
            onComplete: function () {
                barb.enterTile();
            },
            onCompleteScope: movementTweenBarb
        });
        
	}
    
    function update () {
        if (moveButton.mode == "planning") {
            moveButton.x = this.game.input.activePointer.x + 50;
            moveButton.y = this.game.input.activePointer.y + 50;
        } else if (moveButton.mode == "moving" && movementTweenBarb.isPlaying() == false && movementTweenRogue.isPlaying() == false && movementTweenMage.isPlaying() == false) {
            let activeChar = figuresOnMap[figuresOnMap.findIndex(findActiveChar)];
            activeChar.moveNow();
        }
        
        if (searchButton.mode == "planning") {
            searchButton.x = this.game.input.activePointer.x + 50;
            searchButton.y = this.game.input.activePointer.y + 50;
        }
            
        if (attackButton.mode == "planning rc" || attackButton.mode == "planning cc") {
            attackButton.x = this.game.input.activePointer.x + 50;
            attackButton.y = this.game.input.activePointer.y + 50;
        }
        
        swirl1.rotation += 0.01;
        swirl2.rotation -= 0.02;
    }

    function findActiveChar(element) {
        return element.active == true;
    }
    
    function findDeadChar(element) {
        return element.health <= 0;
    }

    function buildLevel() {
        let levelMap = returnLevelType(1);
        for (var i = 0; i < tileArray.length; i++) {
            tileArray[i].state = levelMap[i];
            tileArray[i].updateState();
        }
        let levelMapConnections = returnLevelConnections(1);
        for (var i = 0; i < tileArray.length; i++) {
            tileArray[i].walkable = levelMapConnections[i];
        }
        let levelMapInfo = returnLevelInfo(1);
        for (var i = 0; i < tileArray.length; i++) {
            tileArray[i].info = levelMapInfo[i];
        }
        
        for (var i = 0; i < figuresOnMap.length; i++) {
            figuresOnMap[i].setOnMap();
        }
        
        tileArray[941].occupiedBy = "idol";
        eventDispatch("", "e1");
    }

    function lineOfSight (activeChar, endIndex) {
        let aX = activeChar.onTile % matrixWidth;
        let aY = Math.floor(activeChar.onTile / matrixWidth);
        
        let bX = endIndex % matrixWidth;
        let bY = Math.floor(endIndex / matrixWidth);
        
        let difX = aX-bX;
        let difY = aY-bY;
        
        let index = activeChar.onTile;
        
        let diagonals = Math.min(Math.abs(difY), Math.abs(difX)); // die kleinere Differenz in der Entfernung sind die Diagonalen
        let straights = Math.max(Math.abs(difY), Math.abs(difX))-diagonals; // der Rest der Entfernung sind Geraden
        let stepDiagonals = 1/(diagonals+1);
        let stepStraights = 1/(straights+1);
        let pointer = 0;
        let pointerIncrement = stepDiagonals * stepStraights;
        
        let losPathDifficulty = [];
        
        if ( Math.abs(difX) >= Math.abs(difY) ) { // liegt Links oder Rechts 
            if (difX > 0) { //liegt Links
                while  (aX > bX) {
                    pointer += pointerIncrement;
                    if (pointer >= stepDiagonals && difY > 0) { // N-W
                        stepDiagonals += 1/(diagonals+1);
                        index = index - matrixWidth - 1;
                        losPathDifficulty.push(tileArray[index].walkable[4]);
                        aX--;
                    } else if (pointer >= stepDiagonals && difY < 0) { // S-W
                        stepDiagonals += 1/(diagonals+1);
                        index = index + matrixWidth - 1;
                        losPathDifficulty.push(tileArray[index].walkable[2]);
                        aX--;
                    } else if (pointer >= stepStraights || difY == 0) { // W
                        stepStraights += 1/(straights+1);
                        index = index - 1;
                        losPathDifficulty.push(tileArray[index].walkable[3]);
                        aX--;
                    }
                }
            } else if (difX < 0) { // liegt Rechts
                while  (aX < bX) {
                    pointer += pointerIncrement;
                    if (pointer >= stepDiagonals && difY > 0) { // N-O
                        stepDiagonals += 1/(diagonals+1);
                        index = index - matrixWidth + 1;
                        losPathDifficulty.push(tileArray[index].walkable[6]);
                        aX++;
                    } else if (pointer >= stepDiagonals && difY < 0) { // S-O
                        stepDiagonals += 1/(diagonals+1);
                        index = index + matrixWidth + 1;
                        losPathDifficulty.push(tileArray[index].walkable[0]);
                        aX++;
                    } else if (pointer >= stepStraights || difY == 0) { // O
                        stepStraights += 1/(straights+1);
                        index = index + 1;
                        losPathDifficulty.push(tileArray[index].walkable[7]);
                        aX++;
                    }
                }
            }
        } else if ( Math.abs(difX) < Math.abs(difY) ) {// liegt Über oder Unter
            if (difY > 0) { //liegt Über
                while  (aY > bY) {
                    pointer += pointerIncrement;
                    if (pointer >= stepDiagonals && difX > 0) { // N-W
                        stepDiagonals += 1/(diagonals+1);
                        index = index - matrixWidth - 1;
                        losPathDifficulty.push(tileArray[index].walkable[4]);
                        aY--;
                    } else if (pointer >= stepDiagonals && difX < 0) { // N-O
                        stepDiagonals += 1/(diagonals+1);
                        index = index - matrixWidth + 1;
                        losPathDifficulty.push(tileArray[index].walkable[6]);
                        aY--;
                    } else if (pointer >= stepStraights || difX == 0) { // N
                        stepStraights += 1/(straights+1);
                        index = index - matrixWidth;
                        losPathDifficulty.push(tileArray[index].walkable[5]);
                        aY--;
                    }
                }
            } else if (difY < 0) { // liegt Unter
                while  (aY < bY) {
                    pointer += pointerIncrement;
                    if (pointer >= stepDiagonals && difX > 0) { // S-W
                        stepDiagonals += 1/(diagonals+1);
                        index = index + matrixWidth - 1;
                        losPathDifficulty.push(tileArray[index].walkable[2]);
                        aY++;
                    } else if (pointer >= stepDiagonals && difX < 0) { // S-O
                        stepDiagonals += 1/(diagonals+1);
                        index = index + matrixWidth + 1;
                        losPathDifficulty.push(tileArray[index].walkable[0]);
                        aY++;
                    } else if (pointer >= stepStraights || difX == 0) { // S
                        stepStraights += 1/(straights+1);
                        index = index + matrixWidth;
                        losPathDifficulty.push(tileArray[index].walkable[1]);
                        aY++;
                    }
                }
            }
        }
        
        searchButton.mode = "none";
        
        let los_blocked = losPathDifficulty.includes(0); // testet ob in dem Array "losPathDifficulty" eine 0 vorkommt (dort kann man nicht hinlaufen)
        return !los_blocked; // gibt "true" zurück, wenn man in direkter Linie zum angesehenen Punkt laufen/schwimmen/... könnte.
    }

    function showPath (startIndex, endIndex) {
        
        var mappedList = [];
        var frontierList = [];
        var frontierListValues = [];
        var activeNode;
        var pathFound = false;
        var pathToTravel = [];

        // finde A und füge ihn der frontierList hinzu {name, wayPointUsefulness}
        tileArray[startIndex].entryPoint = "Start";
        tileArray[startIndex].distanceTravelled = 0;
        tileArray[startIndex].wayPointUsefulness = tileArray[startIndex].distanceTravelled + tileArray[startIndex].estimatedWayToB(endIndex);
        frontierList.push(tileArray[startIndex]);
        
        // gehe folgende Schleife solange durch bis es einen Weg gibt
        mapperLoop: while (pathFound == false) {

            // gehe frontierList durch nach niedrigster wayPointUsefulness
            frontierListValues.length = 0;
            for (var i = 0; i < frontierList.length; i++) {
                frontierListValues.push(frontierList[i].wayPointUsefulness);
            };
            if (frontierList.length == 0) {
                return;
            };
            activeNode = frontierListValues.indexOf(Math.min(...frontierListValues));

            // Wenn Knoten mit Niedrigster wayPointUsefulness schon das Ziel ist, ist A* fertig
            if (frontierList[activeNode].name == endIndex) {
                pathFound = true; // unterbricht das Pfadsuchen
                let backtraceIndex = endIndex; // Sucht den Index des Zielfeldes
                pathToTravel.unshift(backtraceIndex); // Fügt das Zielfeld dem Pfad hinzu

                while (tileArray[tileArray[backtraceIndex].entryPoint].name != startIndex) {
                    pathToTravel.unshift(tileArray[backtraceIndex].entryPoint);
                    backtraceIndex = tileArray[backtraceIndex].entryPoint;
                }

                break mapperLoop;
            }

            // berechne für diesen alle neighbors
            frontierList[activeNode].checkForNeighbors();

            // Füge Neighbors des aktuellen Knotens der Frontierlist hinzu
            for (var i = 0; i < frontierList[activeNode].neighbors.length; i++) {

                let distanceTravelled = frontierList[activeNode].distanceTravelled + frontierList[activeNode].neighborsDistance[i];
                if (containsObject(frontierList[activeNode].neighbors[i], frontierList)) {
                    if (distanceTravelled < frontierList[activeNode].neighbors[i].distanceTravelled) {
                        frontierList[activeNode].neighbors[i].distanceTravelled = distanceTravelled;
                        frontierList[activeNode].neighbors[i].wayPointUsefulness = frontierList[activeNode].neighbors[i].distanceTravelled + frontierList[activeNode].neighbors[i].estimatedWayToB(endIndex);
                        frontierList[activeNode].neighbors[i].entryPoint = frontierList[activeNode].name;
                    }
                } else if (containsObject(frontierList[activeNode].neighbors[i], mappedList)) {
                    continue;
                } else if (frontierList[activeNode].neighbors[i].occupiedBy == "enemy" && tileArray[startIndex].occupiedBy == "figure") {
                    continue;
                } else {
                    frontierList[activeNode].neighbors[i].distanceTravelled = frontierList[activeNode].distanceTravelled + frontierList[activeNode].neighborsDistance[i];
                    frontierList[activeNode].neighbors[i].wayPointUsefulness = frontierList[activeNode].neighbors[i].distanceTravelled + frontierList[activeNode].neighbors[i].estimatedWayToB(endIndex);
                    frontierList[activeNode].neighbors[i].entryPoint = frontierList[activeNode].name;
                    frontierList.push(frontierList[activeNode].neighbors[i]);
                }
            };

            // Füge den aktiven Knoten der mappedList hinzu und Lösche den aktven Knoten aus der frontierList
            mappedList.push(frontierList[activeNode]);
            frontierList.splice(activeNode,1);
        }
        
        let activeChar = figuresOnMap[figuresOnMap.findIndex(findActiveChar)];
        movementStopper: for (var l = 0; l < pathToTravel.length; l++) {
            if (tileArray[pathToTravel[l]].distanceTravelled > (activeChar.movement-activeChar.moved)) {
                console.log(pathToTravel);
                pathToTravel.length = (l);
                console.log(pathToTravel);
                break movementStopper;
            }
        }
        
        clearNodes();
        return pathToTravel;
    }

    function calculatePath (activeChar, endIndex) {
        
        var mappedList = [];
        var frontierList = [];
        var frontierListValues = [];
        var activeNode;
        var pathFound = false;

        activeChar.pathToTravel.length = 0;

        // finde A und füge ihn der frontierList hinzu {name, wayPointUsefulness}
        tileArray[activeChar.onTile].entryPoint = "Start";
        tileArray[activeChar.onTile].distanceTravelled = 0;
        tileArray[activeChar.onTile].wayPointUsefulness = tileArray[activeChar.onTile].distanceTravelled + tileArray[activeChar.onTile].estimatedWayToB(endIndex);
        frontierList.push(tileArray[activeChar.onTile]);
        
        // gehe folgende Schleife solange durch bis es einen Weg gibt
        mapperLoop: while (pathFound == false) {

            // gehe frontierList durch nach niedrigster wayPointUsefulness
            frontierListValues.length = 0;
            for (var i = 0; i < frontierList.length; i++) {
                frontierListValues.push(frontierList[i].wayPointUsefulness);
            };
            if (frontierList.length == 0) {
                showText("", activeChar, textL1[18]);
                return;
            };
            activeNode = frontierListValues.indexOf(Math.min(...frontierListValues));

            // Wenn Knoten mit Niedrigster wayPointUsefulness schon das Ziel ist, ist A* fertig
            if (frontierList[activeNode].name == endIndex) {
                pathFound = true; // unterbricht das Pfadsuchen
                let backtraceIndex = endIndex; // Sucht den Index des Zielfeldes
                activeChar.pathToTravel.unshift(backtraceIndex); // Fügt das Zielfeld dem Pfad hinzu

                while (tileArray[tileArray[backtraceIndex].entryPoint].name != activeChar.onTile) {
                    activeChar.pathToTravel.unshift(tileArray[backtraceIndex].entryPoint);
                    backtraceIndex = tileArray[backtraceIndex].entryPoint;
                }

                break mapperLoop;
            }

            // berechne für diesen alle neighbors
            frontierList[activeNode].checkForNeighbors();

            // Füge Neighbors des aktuellen Knotens der Frontierlist hinzu
            for (var i = 0; i < frontierList[activeNode].neighbors.length; i++) {

                let distanceTravelled = frontierList[activeNode].distanceTravelled + frontierList[activeNode].neighborsDistance[i];
                if (containsObject(frontierList[activeNode].neighbors[i], frontierList)) {
                    if (distanceTravelled < frontierList[activeNode].neighbors[i].distanceTravelled) {
                        frontierList[activeNode].neighbors[i].distanceTravelled = distanceTravelled;
                        frontierList[activeNode].neighbors[i].wayPointUsefulness = frontierList[activeNode].neighbors[i].distanceTravelled + frontierList[activeNode].neighbors[i].estimatedWayToB(endIndex);
                        frontierList[activeNode].neighbors[i].entryPoint = frontierList[activeNode].name;
                    }
                } else if (containsObject(frontierList[activeNode].neighbors[i], mappedList)) {
                    continue;
                } else if (frontierList[activeNode].neighbors[i].occupiedBy == "enemy" && tileArray[activeChar.onTile].occupiedBy == "figure") {
                    continue;
                } else {
                    frontierList[activeNode].neighbors[i].distanceTravelled = frontierList[activeNode].distanceTravelled + frontierList[activeNode].neighborsDistance[i];
                    frontierList[activeNode].neighbors[i].wayPointUsefulness = frontierList[activeNode].neighbors[i].distanceTravelled + frontierList[activeNode].neighbors[i].estimatedWayToB(endIndex);
                    frontierList[activeNode].neighbors[i].entryPoint = frontierList[activeNode].name;
                    frontierList.push(frontierList[activeNode].neighbors[i]);
                }
            };

            // Füge den aktiven Knoten der mappedList hinzu und Lösche den aktven Knoten aus der frontierList
            mappedList.push(frontierList[activeNode]);
            frontierList.splice(activeNode,1);
        }
        
        if (fightmode == true) {
            movementStopper: for (var l = 0; l < activeChar.pathToTravel.length; l++) {
                if (tileArray[activeChar.pathToTravel[l]].distanceTravelled > 6) {
                    activeChar.pathToTravel.length = (l);
                    break movementStopper;
                }
            }
        }
        
        console.log(tileArray[activeChar.pathToTravel[activeChar.pathToTravel.length-1]].distanceTravelled);
        activeChar.moved += tileArray[activeChar.pathToTravel[activeChar.pathToTravel.length-1]].distanceTravelled;
        console.log(activeChar.moved);
        
        clearNodes();
        returnCursorToNormal();
        moveButton.mode = "moving";
    }

    function enemyVisibility () {
        let enemyIndexes = [];
        // Alle Feinde werden unsichtbar
        for (var i = 0; i < figuresOnMap.length; i++) {
            if (tileArray[figuresOnMap[i].onTile].occupiedBy == "enemy") {
                figuresOnMap[i].setAlpha(0);
                enemyIndexes.push(figuresOnMap[i]);
            }
        }
        // Alle Feinde, zu denen LoS besteht, werden wieder sichtbar
        for (var j = 0; j < 3; j++) {
            if (tileArray[figuresOnMap[j].onTile].occupiedBy == "figure") {
                for (var k = 0; k < enemyIndexes.length; k++) {
                    if (lineOfSight (figuresOnMap[j], enemyIndexes[k].onTile)) {
                        enemyIndexes[k].setAlpha(1);
                        if (figuresOnMap[j].stealth == false) {
                            enemyIndexes[k].alarmed = true;
                        }
                    }
                }
            }
        }
        checkFightmode();
    }
    
    function clearNodes() {
        tileArray.forEach(function(element) {
            element.neighbors.length = 0;
            element.neighborsDistance.length = 0;
            element.distanceTravelled = "";
            element.wayPointUsefulness = "";
            element.entryPoint = "";
        });
    }

    function returnCursorToNormal() {
        hideActions();
        moveButton.setScale(1);
        searchButton.setScale(1);
        attackButton.setScale(1);
        attackButton.mode = "none";
    }

    function containsObject(obj, list) {
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }

        return false;
    }
    
    function showText (text1 = "", char = "", text2 = "", text3 = "") {

        Info1.showMessage(text1);
        InfoName.showName(char);
        Info2.showMessage(text2);
        Info3.showMessage(text3);
        
        textHistory.push(Info1.text, InfoName.text, Info2.text, Info3.text);
        textHistoryIndex += 4;
    }
    
    function eventDispatch (activeChar, eventKey) {
        console.log(eventReminder);
        if (eventKey == "0t1") {
            trap1(activeChar);
            activeChar.moveNow;
        } else if (eventKey == "e1") {      // start von Level 1
            showText (textL1[0], figuresOnMap[3], textL1Enemy[0]);
        } else if (eventKey == "e2" && eventReminder.e2 != true) {      // nach dem öffnen der ersten Türe in den tempel
            eventReminder.e2 = true;
            showText (textL1[21]);
        } else if (eventKey == "0e3") {     // erster Gang
            showText (textL1[22], activeChar, textL1[23]);
        } else if (eventKey == "e4" && eventReminder.e4 != true) {      // nach dem öffnen der zweiten Türe in den Hauptraum
            eventReminder.e4 = true;
            showText (textL1[38], figuresOnMap[figuresOnMap.length - 2], textL1[39]);
        } else if (eventKey == "6e5") {     // zweiter Gang
            showText (textL1[22], activeChar, textL1[23]);
        } else if (eventKey == "6e6") { // vor dem Bosskampf
        } else if (eventKey == "e7") {  // Statuette wird zerstört
            addXP (20);
            idol1Img.setAlpha(1);
        } else if (eventKey == "e8") {  // ende von Level 1
        } else if (eventKey == "7e9") { // Kristall im See
            if (activeChar == mage) {
                showText (textL1[24], activeChar, textL1[25]);
            } else if (activeChar == barb) {
                showText (textL1[26], activeChar, textL1[27]);
                activeChar.health -= 1;
            } else if (activeChar == rogue) {
                showText (textL1[28], activeChar, textL1[29]);
                tileArray[120].state = 7;
                crystal1Img.setAlpha(0);
                addXP(12);
            }
        };
    }
    
    function addXP (number) {
        xp += number;
        xpText.setText(xp);
        if (0 <= xp && xp < 15) {
            xpIcon.setFrame(0);
        } else if (5 <= xp && xp < 30) {
            xpIcon.setFrame(1);
        } else if (10 <= xp && xp < 45) {
            xpIcon.setFrame(2);
        } else if (15 <= xp && xp < 60) {
            xpIcon.setFrame(3);
        } else if (20 <= xp) {
            xpIcon.setFrame(4);
        }
    }
    
    function checkFightmode() {
        let alarmedEnemies = 0;
        for (var i = 0; i < figuresOnMap.length; i++) {
            if (tileArray[figuresOnMap[i].onTile].occupiedBy == "enemy" && figuresOnMap[i].alarmed == true) {
                alarmedEnemies++;
            }
        }
        if (alarmedEnemies == 0) {
            fightmode = false;
            gameModeIcon.setFrame(0);
            gameModeText.setText("Exploration");
        } else {
            fightmode = true;
            gameModeIcon.setFrame(1);
            gameModeText.setText("Skirmish");
        }
    }
    
</script>
</body>

</html>