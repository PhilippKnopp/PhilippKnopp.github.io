<!DOCTYPE html>

<html>
<head>
	<meta charset="utf-8" />

	<title>God in the Deep</title>
	
	<style>* { padding: 0; margin: 0;}</style>
	
<script src="//cdn.jsdelivr.net/npm/phaser@3.18.1/dist/phaser.min.js"></script>
<script src="levels.js"></script>
<script src="classes.js"></script>

</head>

<body style="background-color:#0A0C0F; text-align:center;">
	
<script>
	
    console.log("Version 8.3");
    
    // configurations Variable, mit der das Spiel gestartet wird
	var config = {
		type: Phaser.AUTO,
		width: 1920,
		height: 1080,
		physics: {
			default: 'arcade',
			arcade: {
				gravity: { y: 0 },
				debug: false
			}
		},
		scale: { mode: Phaser.Scale.FIT },
		scene: {
			preload: preload,
			create: create,
            update: update
		}
	};
	
    // Variablen, die in der App verwendet werden
	var game = new Phaser.Game(config);
	var objects = {};
	var tileArray = [];
	var matrixWidth = 25;
	var matrixHeight = 40;
    var figureWantsToMove = false;
    var movementTweenBarb;
    var movementTweenMage;
    var movementTweenRogue;
	
	var mapImg;
    var doorButton;
    var moveButton;
    var attackButton;
    var searchButton;
    var faceButton;
    var cancelButton;
    
    var mage;
    var rogue;
    var barb;
    
    var figuresOnMap = [];
    
    var level = 1;

    // Funktion die alle Bilder lädt
	function preload() {
	this.load.image('map-lvl-1', 'img/map-lvl-1.png');
        this.load.spritesheet('tileSprite', 'img/tileSprite.png', { frameWidth: 25, frameHeight: 25 });
        
        this.load.spritesheet('mageSprite', 'img/mToken.png', { frameWidth: 25, frameHeight: 25 });
        this.load.spritesheet('rogueSprite', 'img/rToken.png', { frameWidth: 25, frameHeight: 25 });
        this.load.spritesheet('barbSprite', 'img/bToken.png', { frameWidth: 25, frameHeight: 25 });
        
        this.load.spritesheet('doorSprite', 'img/door.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('moveSprite', 'img/move.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('attackSprite', 'img/attack.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('searchSprite', 'img/search.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('cancelSprite', 'img/cancel.png', { frameWidth: 65, frameHeight: 65 });
        this.load.spritesheet('faceSprite', 'img/face.png', { frameWidth: 85, frameHeight: 85 });
	}

    // Funktion die alle Sachen erstellt
	function create() {
        
		objects.camera = this.cameras.add(0, 0, 1920, 1080);
		objects.camera.setBackgroundColor('#0A0C0F');
        
		mapImg = this.add.image(407, 523, 'map-lvl-1').setAlpha(0.5);
		
		var Info = this.add.text(800, 15, "Click on a Character to activate it\nClick on a Tile to set a Goal, where the Character is supposed to walk", { fontFamily: "Verdana" , color: '#0055aa', lineSpacing: 10 });
        
		/*var buildLevelButton = this.add.text(800, 115, "Insert Walls", { fontFamily: "Verdana" });
		buildLevelButton.setInteractive();
		buildLevelButton.on("pointerup", function pointerUp() {
			buildLevel();
		});*/
		
		var index = 0;
		for (var yPos = 0; yPos < matrixHeight; yPos++ ) {
			for (var xPos = 0; xPos < matrixWidth; xPos++ ) {
                var tile = this.add.sprite(xPos*25+100, yPos*25+26, 'tileSprite');
				tile.state = 0;
                tile.text = "0";
				tile.walkable = [1,1,1,1,1,1,1,1];
				tile.updateState = function () {
					if (this.occupiedBy == "figure") {
                        for (var i = 0; i < figuresOnMap.length; i++) {
                            if (this.name == figuresOnMap[i].onTile) {
                                figuresOnMap[i].mapPosition(this.x, this.y);
                            }
                        }
						this.text = "A";
					};
                    if (this.state == 2) {
						this.setFrame(2);
						this.text = "B";
					} else if (this.state == 3) { 
						this.text = "+";
					} else if (this.state == 4) {
                        this.setFrame(3);
						this.text = "+";
					} else if (this.state == 0) { // normaler Boden
                        this.setFrame(0);
						this.text = "0";
                        this.weight = 1;
						this.walkable = [1,1,1,1,1,1,1,1];
					} else if (this.state == 5) { // Wand
						this.text = "X";
						this.walkable = [0,0,0,0,0,0,0,0];
					} else if (this.state == 6) { // Schwieriges Terrain
						this.text = "0";
						this.walkable = [2,2,2,2,2,2,2,2];
						this.weight = 2;
					} else if (this.state == 7) { // Wasser
						this.text = "W";
						this.walkable = [3,3,3,3,3,3,3,3];
						this.weight = 3;
					} else if (this.state == 8) { // Niedriges Wasser
						this.text = "W";
						this.walkable = [2,2,2,2,2,2,2,2];
						this.weight = 2;
					} else if (this.state == 9) { // Trap
						this.text = "T";
						this.weight = 1;
						this.walkable = [1,1,1,1,1,1,1,1];
					};
				};
				tile.setInteractive();
				tile.on("pointerup", function pointerUp () {
                     // nichts ist auf der Tile und diese ist von einer Seite aus begehbar und der
					if (this.occupiedBy == "" && (this.walkable.indexOf(1) > -1 || this.walkable.indexOf(2) > -1 || this.walkable.indexOf(3) > -1) && figureWantsToMove == true) {
                        this.setFrame(2);
				        this.text = "B";
                        let activeChar = figuresOnMap.findIndex(findActiveChar);
                        calculatePath(figuresOnMap[activeChar]);
                        figuresOnMap[activeChar].moveNow();
                    }
				});
				tile.name = index++;
				tile.neighbors = [];
				tile.neighborsDistance = [];
				tile.checkForNeighbors = function () {
					if (this.name-matrixWidth >= 0 && this.name%matrixWidth != 0 && tileArray[this.name-1-matrixWidth].walkable[4] != 0) {
						this.neighbors.push(tileArray[this.name-1-matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name-1-matrixWidth].walkable[4]);
					};
					if (this.name-matrixWidth >= 0 && tileArray[this.name-matrixWidth].walkable[5] != 0) {
						this.neighbors.push(tileArray[this.name-matrixWidth]);
						this.neighborsDistance.push(1*tileArray[this.name-matrixWidth].walkable[5]);
					};
					if (this.name-matrixWidth >= 0 && this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name-matrixWidth+1].walkable[6] != 0) {
						this.neighbors.push(tileArray[this.name-matrixWidth+1]);
						this.neighborsDistance.push(1.5*tileArray[this.name-matrixWidth+1].walkable[6]);
					};
					if (this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name+1].walkable[7] != 0) {
						this.neighbors.push(tileArray[this.name+1]);
						this.neighborsDistance.push(1*tileArray[this.name+1].walkable[7]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name+1+matrixWidth].walkable[0] != 0) {
						this.neighbors.push(tileArray[this.name+1+matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name+1+matrixWidth].walkable[0]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && tileArray[this.name+matrixWidth].walkable[1] != 0) {
						this.neighbors.push(tileArray[this.name+matrixWidth]);
						this.neighborsDistance.push(1*tileArray[this.name+matrixWidth].walkable[1]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && this.name%matrixWidth != 0 && tileArray[this.name-1+matrixWidth].walkable[2] != 0) {
						this.neighbors.push(tileArray[this.name-1+matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name-1+matrixWidth].walkable[2]);
					};
					if (this.name%matrixWidth != 0 && tileArray[this.name-1].walkable[3] != 0) {
						this.neighbors.push(tileArray[this.name-1]);
						this.neighborsDistance.push(1*tileArray[this.name-1].walkable[3]);
					};
				};
				tile.weight = 1;
				tile.estimatedWayToB = function () {
					
					let a = this.name;
					let b = tileArray.findIndex(findEnd);
					
					let xDistance = (Math.abs(b%matrixWidth-a%matrixWidth));
					let yDistance = Math.abs(Math.floor(b/matrixWidth)-Math.floor(a/matrixWidth));
					let diagonals = Math.min(xDistance, yDistance);
					return xDistance + yDistance - diagonals/2;
				};
				tile.distanceTravelled;
				tile.wayPointUsefulness;
				tile.entryPoint;
                tile.occupiedBy = "";
				tileArray.push(tile);
			}
		}
        
        doorButton = this.add.sprite(400, 400, 'doorSprite').setAlpha(0);
        
        moveButton = this.add.sprite(400, 400, 'moveSprite').setAlpha(0);
        moveButton.setInteractive();
		moveButton.on("pointerup", function pointerUp() {
            figureWantsToMove = true;
            hideActions();
            moveButton.setAlpha(1);
            moveButton.setScale(0.5);
		});
        
        attackButton = this.add.sprite(400, 400, 'attackSprite').setAlpha(0);
        searchButton = this.add.sprite(400, 400, 'searchSprite').setAlpha(0);
        faceButton = this.add.sprite(400, 400, 'faceSprite').setAlpha(0);
        
        cancelButton = this.add.sprite(400, 400, 'cancelSprite').setAlpha(0);
        cancelButton.setInteractive();
        cancelButton.on("pointerup", function pointerUp() {
            hideActions();
            deactivateFigures();
		});
        
        mage = new Figure ({scene:this, x:20, y:20}, 'mageSprite');
        mage.onTile = mageStartingPosition[level];
        mage.pathToTravel.push(mageStartingPosition[level]);
        mage.dieSize = 4;
        figuresOnMap.push(mage);
        
        barb = new Figure ({scene:this, x:20, y:20}, 'barbSprite');
        barb.onTile = barbStartingPosition[level];
        barb.pathToTravel.push(barbStartingPosition[level]);
        barb.dieSize = 12;
        figuresOnMap.push(barb);
        
        rogue = new Figure ({scene:this, x:20, y:20}, 'rogueSprite');
        rogue.onTile = rogueStartingPosition[level];
        rogue.pathToTravel.push(rogueStartingPosition[level]);
        rogue.dieSize = 8;
        figuresOnMap.push(rogue);
        
        buildLevel();
        
        movementTweenMage = this.tweens.add({
            targets: mage,
            x: { value: function () {
                return tileArray[mage.pathToTravel[0]].x;
            }},
            y: { value: function () { 
                return tileArray[mage.pathToTravel[0]].y;
            }},
            duration: 200,
            onComplete: onCompleteHandler3,
            onCompleteParams: []
        });
        
        movementTweenRogue = this.tweens.add({
            targets: rogue,
            x: { value: function () {
                return tileArray[rogue.pathToTravel[0]].x;
            }},
            y: { value: function () { 
                return tileArray[rogue.pathToTravel[0]].y;
            }},
            duration: 200,
            onComplete: onCompleteHandler2,
            onCompleteParams: []
        });
        
        movementTweenBarb = this.tweens.add({
            targets: barb,
            x: { value: function () {
                return tileArray[barb.pathToTravel[0]].x;
            }},
            y: { value: function () { 
                return tileArray[barb.pathToTravel[0]].y;
            }},
            duration: 200,
            onComplete: onCompleteHandler1,
            onCompleteParams: []
        });
        
	}
	
    function onCompleteHandler1 (tween, targets) {
	    console.log(targets[0]);
	    console.log("this1");
        targets[0].pathToTravel.shift();
        targets[0].moveNow();
    }
function onCompleteHandler2 (tween, targets) {
	    console.log(targets[0]);
	    console.log("this2");
        targets[0].pathToTravel.shift();
        targets[0].moveNow();
    }
function onCompleteHandler3 (tween, targets) {
	    console.log(targets[0]);
	    console.log("this3");
        targets[0].pathToTravel.shift();
        targets[0].moveNow();
    }
    
    function update () {
        if (figureWantsToMove == true) {
            moveButton.x = this.game.input.activePointer.x + 50;
            moveButton.y = this.game.input.activePointer.y + 50;
        }
    }

    function findActiveChar(element) {
        return element.active == true;
    }

    function findEnd(element) {
        return element.text == "B";
    }

    function buildLevel() {

        var levelMap = returnLevelType(1);
        for (var i = 0; i < tileArray.length; i++) {
            tileArray[i].state = levelMap[i];
            tileArray[i].updateState();
        }
        var levelMapConnections = returnLevelConnections(1);
        for (var i = 0; i < tileArray.length; i++) {
            tileArray[i].walkable = levelMapConnections[i];
        }

        for (var i = 0; i < figuresOnMap.length; i++) {
            figuresOnMap[i].setOnMap();
        }

    }

    function calculatePath (activeChar) {

        var mappedList = [];
        var frontierList = [];
        var frontierListValues = [];
        var activeNode;
        var pathFound = false;

        activeChar.pathToTravel.length = 0;

        // finde A und füge ihn der frontierList hinzu {name, wayPointUsefulness}
        tileArray[activeChar.onTile].entryPoint = "Start";
        tileArray[activeChar.onTile].distanceTravelled = 0;
        tileArray[activeChar.onTile].wayPointUsefulness = tileArray[activeChar.onTile].distanceTravelled + tileArray[activeChar.onTile].estimatedWayToB();
        frontierList.push(tileArray[activeChar.onTile]);

        // gehe folgende Schleife solange durch bis es einen Weg gibt
        mapperLoop: while (pathFound == false) {

            // gehe frontierList durch nach niedrigster wayPointUsefulness
            frontierListValues.length = 0;
            for (var i = 0; i < frontierList.length; i++) {
                frontierListValues.push(frontierList[i].wayPointUsefulness);
            };
            activeNode = frontierListValues.indexOf(Math.min(...frontierListValues));

            // Wenn Knoten mit Niedrigster wayPointUsefulness schon das Ziel ist, ist A* fertig
            if (frontierList[activeNode].text == "B") {
                pathFound = true; // unterbricht das Pfadsuchen
                let backtraceIndex = tileArray.findIndex(findEnd); // Sucht den Index des Zielfeldes
                activeChar.pathToTravel.unshift(backtraceIndex); // Fügt das Zielfeld dem Pfad hinzu

                while (tileArray[tileArray[backtraceIndex].entryPoint].name != activeChar.onTile) {
                    activeChar.pathToTravel.unshift(tileArray[backtraceIndex].entryPoint);
                    tileArray[tileArray[backtraceIndex].entryPoint].state = 4;
                    tileArray[tileArray[backtraceIndex].entryPoint].updateState();
                    backtraceIndex = tileArray[backtraceIndex].entryPoint;
                }

                break mapperLoop;
            }

            // berechne für diesen alle neighbors
            frontierList[activeNode].checkForNeighbors();

            // Füge Neighbors des aktuellen Knotens der Frontierlist hinzu
            for (var i = 0; i < frontierList[activeNode].neighbors.length; i++) {

                let distanceTravelled = frontierList[activeNode].distanceTravelled + frontierList[activeNode].neighborsDistance[i];
                if (containsObject(frontierList[activeNode].neighbors[i], frontierList)) {
                    if (distanceTravelled < frontierList[activeNode].neighbors[i].distanceTravelled) {
                        frontierList[activeNode].neighbors[i].distanceTravelled = distanceTravelled;
                        frontierList[activeNode].neighbors[i].wayPointUsefulness = frontierList[activeNode].neighbors[i].distanceTravelled + frontierList[activeNode].neighbors[i].estimatedWayToB();
                        frontierList[activeNode].neighbors[i].entryPoint = frontierList[activeNode].name;
                    }
                } else if (containsObject(frontierList[activeNode].neighbors[i], mappedList)) {
                    continue;
                } else {
                    frontierList[activeNode].neighbors[i].distanceTravelled = frontierList[activeNode].distanceTravelled + frontierList[activeNode].neighborsDistance[i];
                    frontierList[activeNode].neighbors[i].wayPointUsefulness = frontierList[activeNode].neighbors[i].distanceTravelled + frontierList[activeNode].neighbors[i].estimatedWayToB();
                    frontierList[activeNode].neighbors[i].entryPoint = frontierList[activeNode].name;
                    frontierList.push(frontierList[activeNode].neighbors[i]);
                    if (frontierList[activeNode].neighbors[i].text != "B") {
                        frontierList[activeNode].neighbors[i].state = 3;
                        frontierList[activeNode].neighbors[i].updateState();
                    }
                }
            };

            // Füge den aktiven Knoten der mappedList hinzu und Lösche den aktven Knoten aus der frontierList
            mappedList.push(frontierList[activeNode]);
            frontierList.splice(activeNode,1);

        }

        clearNodes();
        returnCursorToNormal();
        //activeChar.activateFigure();
    }

    function clearNodes() {
        tileArray.forEach(function(element) {
            element.neighbors.length = 0;
            element.distanceTravelled = "";
            element.wayPointUsefulness = "";
            element.entryPoint = "";
        });
    }

    function returnCursorToNormal() {
        figureWantsToMove = false;
        hideActions();
        moveButton.setScale(1);
    }

    function containsObject(obj, list) {
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }

        return false;
    }
	
</script>
</body>

</html>
