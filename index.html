<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    
    <title>God in the Deep</title>
    
    <style>* { padding: 0; margin: 0;}</style>
    
    <script src="//cdn.jsdelivr.net/npm/phaser@3.23.0/dist/phaser.min.js"></script>
    <script src="scenes.js"></script>
    <script src="levels.js"></script>
    <script src="heroines.js"></script>
    <script src="enemies.js"></script>
    <script src="animations.js"></script>
    <script src="random.js"></script>
    <script src="gui.js"></script>
    <script src="enemyAI.js"></script>
    <script src="pathFinder.js"></script>
    
</head>

<body style="background-color:#0C0E11; text-align:center;">
	
<script>
    
////////////// configurations Variable, mit der das Spiel gestartet wird  ////////////////////////////////////////////////////////////////////////////
    
	const config = {
		type: Phaser.AUTO,
		width: 1920,
		height: 1080,
		physics: {
			default: 'arcade',
			arcade: {
				gravity: { y: 0 },
				debug: false
			}
        },
        backgroundColor: '#0C0E11',
        scale: { mode: Phaser.Scale.FIT },
        scene: [SceneTitle, SceneTravel_1, SceneGame, SceneGameOver]
	}
    
////////////// Variablen, die in der App verwendet werden   //////////////////////////////////////////////////////////////////////////////////////////
    
    var gameVersion = "Version 0.32 Test B";
    var game = new Phaser.Game(config);
    var level = 1;
    
    var tileArray = []; // Array mit allen Spielfeldern des Levels
    var matrixWidth = 25;   // Spielfeldbreite
    var matrixHeight = 40;  // Spielfeldhöhe
    
    var movementMarker; // Wird auf der Karte bewegt und die aktive Figur ist an ihn magnetisiert um sich mitzubewegen.
    var movementTween;  // Animationsbewegung, die den movementMarker bewegt
    
    var doorButton, moveButton, attackButton, searchButton,
        faceButton, specialButton, cancelButton;
    var enemyHealthBase, enemyHealthBar;
    var textBackButton, textNextButton, textNewButton;
    
    var mapImg;
    var crystal1Img, idol1Img, circle1Img;
    var door1Img, door2Img, door4Img, door5Img, door6Img;
    var trap1Sprt;
    var swirl1, swirl2;
    
    var mage, rogue, barb;
    var rangedDamage = [0]; // Überschüssiger Schaden der Magierin kann auf zusätzliche Ziele verteilt werden
    var eventReminder = {e2:false, e4:false, e6:false, e7:false, ritualProgress: 13, ritualMembers: 5, ritualState: ""}; // Dinge die nur einmal passieren sollen
    
    var figuresOnMap = [];
    var activeChar = null;  // Variable in der die Spielfigut gespeichert wird, die gerade aktiv ist um schnell darauf zugreifen zu können.
    var turnOver = []; // Array mit allen Helden die in der aktuellen runde schon agiert haben.
    var enemyTurnActive = false;
    var charsStillAlive = 3;
    var Info1, InfoName1, InfoDialog1, InfoName2, InfoDialog2, Info3;
    var textHistory = [];
    var textHistoryIndex = -1;
    var gameModeIcon;
    var gameModeText;
    var xp = 0;
    var xpIcon;
    var xpText;
    var bActionIcon, rActionIcon, mActionIcon;
    var bHpText, rHpText, mHpText, bMovementText, rMovementText, mMovementText;
    
    var fightmode = false;
    
    var bgmusic;
    var m_hit_1, m_hit_2, m_hit_3, m_hit_4, m_miss_1, m_hit_2;
    var melee_hits = [m_hit_1, m_hit_2, m_hit_3, m_hit_4];
    var melee_misses = [m_miss_1, m_hit_2];
    
    
//////////////  Diverse Funktionen   //////////////////////////////////////////////////////////////////////////////////////////

    function findDeadChar(element) {
        if (element instanceof Enemy) {
            return element.health <= 0;
        }
        return false;
    }

    function buildLevel() {
        // Grundlegende Art des Feldes auf der Karte wird eingestellt
        let levelMap = returnLevelType(level);
        for (let i = 0; i < tileArray.length; i++) {
            tileArray[i].state = levelMap[i];
        }
        
        // Schwierigkeit das Feld zu betreten wird eingestellt
        let levelMapConnections = returnLevelConnections(level);
        for (let i = 0; i < tileArray.length; i++) {
            tileArray[i].walkable = levelMapConnections[i];
        }
        
        // Was wird gesehen wenn man das Feld anschaut
        let levelMapInfo = returnLevelInfo(level);
        for (let i = 0; i < tileArray.length; i++) {
            tileArray[i].info = levelMapInfo[i];
        }
        
        // Erstellte Figuren werden auf der Karte Platziert und Registriert
        for (let i = 0; i < figuresOnMap.length; i++) {
            figuresOnMap[i].setOnMap();
        }
        
        tileArray[941].occupiedBy = "idol";
        eventDispatch("e1");
    }

    function enemyVisibility () {
        let enemyIndexes = [];
        // Alle Feinde werden unsichtbar
        for (var i = 0; i < figuresOnMap.length; i++) {
            if (figuresOnMap[i] instanceof Enemy) {
                figuresOnMap[i].setAlpha(0);
                enemyIndexes.push(figuresOnMap[i]);
            }
        }
        // Alle Feinde, zu denen LoS besteht, werden wieder sichtbar
        for (var j = 0; j < charsStillAlive; j++) {
            for (var k = 0; k < enemyIndexes.length; k++) {
                if (lineOfSight (figuresOnMap[j].onTile, enemyIndexes[k].onTile) && figuresOnMap[j].health > 0) {
                    if (enemyIndexes[k].name != "Ordrak" || eventReminder.ritualState == "succesful") {
                        enemyIndexes[k].setAlpha(1);
                        if (figuresOnMap[j].skills.stealth.active == false) {
                            enemyIndexes[k].alarmed = true;
                        }
                    }
                }
            }
        }
    }
    
    /*function tileVisibility () { 
        for (var i = 0; i < tileArray.length; i++) {
            if ((lineOfSight (figuresOnMap[0].onTile, i) && figuresOnMap[0] instanceof Figure ) || (lineOfSight (figuresOnMap[1].onTile, i) && figuresOnMap[1] instanceof Figure ) || (lineOfSight (figuresOnMap[2].onTile, i) && figuresOnMap[2] instanceof Figure )) {
                tileArray[i].setFrame(0);
            } else {
                tileArray[i].setFrame(2);
            }
        }
    }*/
    
    function completeTurn(char) {
        hideActions();
        deactivateFigures();
        // Tote Charactere werden ignoriert wenn es um den Zug geht
        for (let i = 0; i < charsStillAlive; i++) {
            if (figuresOnMap[i].health <= 0 && turnOver.includes(figuresOnMap[i].name) == false) {
                turnOver.push(figuresOnMap[i].name);
            }
        }
        if (turnOver.includes(char.name) == false) {
            turnOver.push(char.name);
        }
        if (turnOver.length == charsStillAlive) {
            turnOver.length = 0;
            // in update function werden jetzt die Gegner gesteuert
            enemyTurnActive = true;
            enemyTurn();
        }
    }
    
    function clearNodes() { 
        tileArray.forEach(function(element) {
            element.neighbors.length = 0;
            element.neighborsDistance.length = 0;
            element.distanceTravelled = "";
            element.wayPointUsefulness = "";
            element.entryPoint = "";
        });
    }

    function returnCursorToNormal() { 
        hideActions();
        moveButton.setScale(1);
        searchButton.setScale(1);
        attackButton.setScale(1);
        attackButton.state = 0;
        moveButton.state = 0;
    }

    function containsObject(obj, list) { 
        for (var i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }
        return false;
    }
    
    function showText (info1 = "", char1 = "", text1 = "", char2 = "", text2 = "", help = "", addToTextHistory = true) {
        
        Info1.showMessage(info1);
        InfoName1.showName(char1);
        InfoDialog1.showMessage(text1);
        InfoName2.showName(char2);
        InfoDialog2.showMessage(text2);
        Info3.showMessage(help);
        
        if (addToTextHistory == true) {
            addTextToArchive(Info1.text, InfoName1.text, InfoDialog1.text, InfoName2.text, InfoDialog2.text, Info3.text);
        }
    
    }
    
    function addTextToArchive (text_1 = "", text_2 = "", text_3 = "", text_4 = "", text_5 = "", text_6 = "") {
        
        if (text_1 != textHistory[textHistoryIndex-5] || text_2 != textHistory[textHistoryIndex-4] || text_3 != textHistory[textHistoryIndex-3] || text_4 != textHistory[textHistoryIndex-2] || text_5 != textHistory[textHistoryIndex-1] || text_6 != textHistory[textHistoryIndex]) {
            textHistory.push(text_1, text_2, text_3, text_4, text_5, text_6);
            textHistoryIndex = textHistory.length-1;
        }
    }
    
    function eventDispatch (eventKey) { 
        if (eventKey == "0t1") {
            trap1(activeChar);
        } else if (eventKey == "e1") {
        // start von Level 1
            showText (textL1[0], figuresOnMap[7], textL1Enemy[0], "", "", textL1[9]);
        } else if (eventKey == "e2" && eventReminder.e2 != true) {
        // nach dem öffnen der ersten Türe in den tempel
            eventReminder.e2 = true;
            showText (textL1[21]);
        } else if (eventKey == "0e3") {
        // erster Gang
            showText (textL1[22], activeChar, textL1[23]);
        } else if (eventKey == "e4" && eventReminder.e4 != true) {
        // nach dem öffnen der zweiten Türe in den Hauptraum
            eventReminder.e4 = true;
            showText (textL1[38], figuresOnMap[figuresOnMap.length - 2], textL1Enemy[1]);
        } else if (eventKey == "6e5") {
        // zweiter Gang
            showText (textL1[22], activeChar, textL1[23]);
        } else if (eventKey == "6e6" && eventReminder.e6 != true) {
        // vor dem Bosskampf
            eventReminder.e6 = true;
            showText(textL1[43], mage, textL1[44]);
        } else if (eventKey == "e7") {
        // Statuette wird zerstört
            addXP (20);
            idol1Img.setAlpha(1);
            eventReminder.e7 = true;
            showText(textL1[46], mage, textL1[47], rogue, textL1[48]);
            for (let i = 0; i < figuresOnMap.length; i++) {
                if (figuresOnMap[i].name == "Pale Priest") {
                    figuresOnMap[i].specialAttack.roll.push(7);
                    figuresOnMap[i].specialAttack.name.push("unholy energy");
                } else if (figuresOnMap[i].name == "Ordrak") {
                    figuresOnMap[i].specialAttack.roll.push(7);
                    figuresOnMap[i].specialAttack.name.push("darkness");
                }
            }
        } else if (eventKey == "e8") {
        // ende von Level 1
            showText (textL1[15]);
        } else if (eventKey == "7e9") {
        // Kristall im See
            if (fightmode == true) {
                showText ("", activeChar, textL1[42]);
            } else {
                if (activeChar == mage) {
                    showText (textL1[24], activeChar, textL1[25]);
                } else if (activeChar == barb) {
                    activeChar.health -= 1;
                    activeChar.checkHealth();
                    if (activeChar.health > 0) {
                        showText (textL1[26], activeChar, textL1[27]);
                    } else {
                        showText (textL1[40], rogue, textL1[41]);
                    }
                } else if (activeChar == rogue) {
                    showText (textL1[28], activeChar, textL1[29]);
                    tileArray[120].state = 7;
                    crystal1Img.setAlpha(0);
                    addXP(12);
                }
            }
        }
    }
    
    function addXP (number) {
        xp += number;
        xpText.setText(xp);
        if (0 <= xp && xp < 25) {
            xpIcon.setFrame(0);
        } else if (25 <= xp && xp < 50) {
            xpIcon.setFrame(1);
        } else if (50 <= xp && xp < 75) {
            xpIcon.setFrame(2);
        } else if (75 <= xp && xp < 100) {
            xpIcon.setFrame(3);
        } else {
            xpIcon.setFrame(4);
        }
    }
    
    function updateGUI () {
        bActionIcon.setAlpha(barb.actionsCounter);
        rActionIcon.setAlpha(rogue.actionsCounter);
        mActionIcon.setAlpha(mage.actionsCounter);
        bHpText.setText(barb.health + "/" + barb.fullHealth);
        rHpText.setText(rogue.health + "/" + rogue.fullHealth);
        mHpText.setText(mage.health + "/" + mage.fullHealth);
        bMovementText.setText(barb.movementCounter + "/" + barb.movement);
        rMovementText.setText(rogue.movementCounter + "/" + rogue.movement);
        mMovementText.setText(mage.movementCounter + "/" + mage.movement);
    }
    
    function checkFightmode() { 
        let alarmedEnemies = 0;
        for (var i = 0; i < figuresOnMap.length; i++) {
            if (tileArray[figuresOnMap[i].onTile].occupiedBy == "enemy" && figuresOnMap[i].alarmed == true) {
                alarmedEnemies++;
            }
        }
        if (alarmedEnemies == 0 && fightmode == true) {
            fightmode = false;
            gameModeIcon.setFrame(0);
            gameModeText.setText("Exploration");
            turnOver.length = 0;
            enemyTurnActive = false;
            replenishActions();
        } else if (alarmedEnemies > 0 && fightmode == false) {
            fightmode = true;
            gameModeIcon.setFrame(1);
            gameModeText.setText("Skirmish");
            if (activeChar != null) {
                activeChar.pathToTravel.length = 0;
            }
        }
    }
    
    function restartLevel() {

        tileArray.length = 0;
        
        rangedDamage = [0];
        eventReminder = {e2:false, e4:false, e6:false, e7:false, ritualProgress: 13, ritualMembers: 5, ritualState: ""};
        
        figuresOnMap.length = 0;
        activeChar = null;
        turnOver.length = 0;
        enemyTurnActive = false;
        textHistory.length = 0;
        textHistoryIndex = -1;
        xp = 0;
        
        fightmode = false;
        
    }
    
</script>
</body>

</html>