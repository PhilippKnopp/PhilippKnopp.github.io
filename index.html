<!DOCTYPE html>

<html>
<head>
	<meta charset="utf-8" />

	<title>God in the Deep</title>
	
	<style>* { padding: 0; margin: 0;}</style>
	
<script src="//cdn.jsdelivr.net/npm/phaser@3.18.1/dist/phaser.min.js"></script>
<script src="levels.js"></script>
<script src="classes.js"></script>

</head>

<body style="background-color:#0A0C0F; text-align:center;">
	
<script>
	
	var config = {
		type: Phaser.AUTO,
		width: 1920,
		height: 1080,
		physics: {
			default: 'arcade',
			arcade: {
				gravity: { y: 0 },
				debug: false
			}
		},
		scale: { mode: Phaser.Scale.FIT },
		scene: {
			preload: preload,
			create: create
		}
	};
	
	var game = new Phaser.Game(config);
	var objects = {};
	var tileArray = [];
	var matrixWidth = 23;
	var matrixHeight = 39;
	
	var mapImg;
    var mage;
    var rogue;
    var barb;
    
    var figuresOnMap = [];
    
    var level = 1;

	function preload() {
		console.log("Version 5.1");
		this.load.image('map-lvl-1', 'img/map-lvl-1.png');
        this.load.spritesheet('tileSprite', 'img/tileSprite.png', { frameWidth: 25, frameHeight: 25 });
        
        this.load.spritesheet('mageSprite', 'img/mToken.png', { frameWidth: 25, frameHeight: 25 });
        this.load.spritesheet('rogueSprite', 'img/rToken.png', { frameWidth: 25, frameHeight: 25 });
        this.load.spritesheet('barbSprite', 'img/bToken.png', { frameWidth: 25, frameHeight: 25 });
	}

	function create() {
		
		objects.camera = this.cameras.add(0, 0, 1920, 1080);
		objects.camera.setBackgroundColor('#0A0C0F');
        
		mapImg = this.add.image(297, 498, 'map-lvl-1').setAlpha(0.5);
		
		
		var Info = this.add.text(600, 15, "Click on a Character to activate it\nClick on a Tile to set a Goal, where the Character is supposed to walk", { fontFamily: "Verdana" , color: '#0055aa', lineSpacing: 10 });
		
		var calculatePathButton = this.add.text(600, 85, "Calculate Path", { fontFamily: "Verdana" });
		calculatePathButton.setInteractive();
		calculatePathButton.on("pointerup", function pointerUp() {
            let activeChar = figuresOnMap.findIndex(findActiveChar);
			calculatePath(figuresOnMap[activeChar].onTile);
		});
		
		/*var insertWallsButton = this.add.text(600, 115, "Insert Walls", { fontFamily: "Verdana" });
		insertWallsButton.setInteractive();
		insertWallsButton.on("pointerup", function pointerUp() {
			insertWalls();
		});*/
		
		var resetButton = this.add.text(600, 145, "Reset", { fontFamily: "Verdana" });
		resetButton.setInteractive();
		resetButton.on("pointerup", function pointerUp() {
			resetView();
		});
		
		var index = 0;
		for (var yPos = 0; yPos < matrixHeight; yPos++ ) {
			for (var xPos = 0; xPos < matrixWidth; xPos++ ) {
                var tile = this.add.sprite(xPos*25+15, yPos*25+26, 'tileSprite');
				tile.setAlpha(1);
				tile.state = 0;
                tile.text = "0";
				tile.walkable = [1,1,1,1,1,1,1,1];
				tile.updateState = function () {
					if (this.occupiedBy == "figure") {
                        for (var i = 0; i < figuresOnMap.length; i++) {
                            if (this.name == figuresOnMap[i].onTile) {
                                figuresOnMap[i].mapPosition(this.x, this.y);
                            }
                        }
						this.text = "A";
					};
                    if (this.state == 2) {
						this.setFrame(2);
						this.text = "B";
					} else if (this.state == 3) { 
						this.text = "+";
					} else if (this.state == 4) {
                        this.setFrame(3);
						this.text = "+";
					} else if (this.state == 0) { // normaler Boden
                        this.setFrame(0);
						this.text = "0";
                        this.weight = 1;
						this.walkable = [1,1,1,1,1,1,1,1];
					} else if (this.state == 5) { // Wand
						this.text = "X";
						this.walkable = [0,0,0,0,0,0,0,0];
					} else if (this.state == 6) { // Schwieriges Terrain
						this.text = "0";
						this.walkable = [2,2,2,2,2,2,2,2];
						this.weight = 2;
					} else if (this.state == 7) { // Wasser
						this.text = "W";
						this.walkable = [3,3,3,3,3,3,3,3];
						this.weight = 3;
					} else if (this.state == 8) { // Niedriges Wasser
						this.text = "W";
						this.walkable = [2,2,2,2,2,2,2,2];
						this.weight = 2;
					} else if (this.state == 9) { // Trap
						this.text = "T";
						this.weight = 1;
						this.walkable = [1,1,1,1,1,1,1,1];
					};
				};
				tile.setInteractive();
				tile.on("pointerup", function pointerUp () {
					if (this.state < 2) {
						this.state = 2;
					} else {
						this.state = 0;
					};
					this.updateState();
				});
				tile.name = index++;
				tile.neighbors = [];
				tile.neighborsDistance = [];
				tile.checkForNeighbors = function () {
					if (this.name-matrixWidth >= 0 && this.name%matrixWidth != 0 && tileArray[this.name-1-matrixWidth].walkable[4] != 0) {
						this.neighbors.push(tileArray[this.name-1-matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name-1-matrixWidth].walkable[4]);
					};
					if (this.name-matrixWidth >= 0 && tileArray[this.name-matrixWidth].walkable[5] != 0) {
						this.neighbors.push(tileArray[this.name-matrixWidth]);
						this.neighborsDistance.push(1*tileArray[this.name-matrixWidth].walkable[5]);
					};
					if (this.name-matrixWidth >= 0 && this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name-matrixWidth+1].walkable[6] != 0) {
						this.neighbors.push(tileArray[this.name-matrixWidth+1]);
						this.neighborsDistance.push(1.5*tileArray[this.name-matrixWidth+1].walkable[6]);
					};
					if (this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name+1].walkable[7] != 0) {
						this.neighbors.push(tileArray[this.name+1]);
						this.neighborsDistance.push(1*tileArray[this.name+1].walkable[7]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && this.name%matrixWidth != (matrixWidth-1) && tileArray[this.name+1+matrixWidth].walkable[0] != 0) {
						this.neighbors.push(tileArray[this.name+1+matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name+1+matrixWidth].walkable[0]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && tileArray[this.name+matrixWidth].walkable[1] != 0) {
						this.neighbors.push(tileArray[this.name+matrixWidth]);
						this.neighborsDistance.push(1*tileArray[this.name+matrixWidth].walkable[1]);
					};
					if (this.name+matrixWidth < (matrixWidth*matrixHeight) && this.name%matrixWidth != 0 && tileArray[this.name-1+matrixWidth].walkable[2] != 0) {
						this.neighbors.push(tileArray[this.name-1+matrixWidth]);
						this.neighborsDistance.push(1.5*tileArray[this.name-1+matrixWidth].walkable[2]);
					};
					if (this.name%matrixWidth != 0 && tileArray[this.name-1].walkable[3] != 0) {
						this.neighbors.push(tileArray[this.name-1]);
						this.neighborsDistance.push(1*tileArray[this.name-1].walkable[3]);
					};
				};
				tile.weight = 1;
				tile.estimatedWayToB = function () {
					
					let a = this.name;
					let b = tileArray.findIndex(findEnd);
					
					let xDistance = (Math.abs(b%matrixWidth-a%matrixWidth));
					let yDistance = Math.abs(Math.floor(b/matrixWidth)-Math.floor(a/matrixWidth));
					let diagonals = Math.min(xDistance, yDistance);
					return xDistance + yDistance - diagonals/2;
				};
				tile.distanceTravelled;
				tile.wayPointUsefulness;
				tile.entryPoint;
                tile.occupiedBy;
				tileArray.push(tile);
			}
		}
        
        mage = new Figure ({scene:this, x:20, y:20}, 'mageSprite');
        mage.onTile = mageStartingPosition[level];
        mage.dieSize = 4;
        figuresOnMap.push(mage);
        
        barb = new Figure ({scene:this, x:20, y:20}, 'barbSprite');
        barb.onTile = barbStartingPosition[level];
        barb.dieSize = 12;
        figuresOnMap.push(barb);
        
        rogue = new Figure ({scene:this, x:20, y:20}, 'rogueSprite');
        rogue.onTile = rogueStartingPosition[level];
        rogue.dieSize = 8;
        figuresOnMap.push(rogue);
        
        insertWalls();
        
	}
	
function findActiveChar(element) {
    return element.active == true;
}
    
function findEnd(element) {
    return element.text == "B";
}
	
function insertWalls() {
	
	var levelMap = returnLevelType(1);
	for (var i = 0; i < tileArray.length; i++) {
		tileArray[i].state = levelMap[i];
		tileArray[i].updateState();
	}
	var levelMapConnections = returnLevelConnections(1);
	for (var i = 0; i < tileArray.length; i++) {
		tileArray[i].walkable = levelMapConnections[i];
	}
    
    for (var i = 0; i < figuresOnMap.length; i++) {
        figuresOnMap[i].setOnMap();
    }
    
}

function resetView() {
	for (var i = 0; i < tileArray.length; i++) {
		tileArray[i].state = 0;
		tileArray[i].updateState();
	}
}
	
function calculatePath (nameOfA) {
	
	var mappedList = [];
	var frontierList = [];
	var frontierListValues = [];
	var path = [];
	var activeNode;
	var pathFound = false;
	
	
	// finde A und füge ihn der frontierList hinzu {name, wayPointUsefulness}
	tileArray[nameOfA].entryPoint = "Start";
	tileArray[nameOfA].distanceTravelled = 0;
	tileArray[nameOfA].wayPointUsefulness = tileArray[nameOfA].distanceTravelled + tileArray[nameOfA].estimatedWayToB();
	frontierList.push(tileArray[nameOfA]);
	
	// gehe folgende Schleife solange durch bis es einen Weg gibt
	mapperLoop: while (pathFound == false) {

        // gehe frontierList durch nach niedrigster wayPointUsefulness
        frontierListValues.length = 0;
        for (var i = 0; i < frontierList.length; i++) {
            frontierListValues.push(frontierList[i].wayPointUsefulness);
        };
        activeNode = frontierListValues.indexOf(Math.min(...frontierListValues));

        // Wenn Knoten mit Niedrigster wayPointUsefulness schon das Ziel ist, ist A* fertig
        if (frontierList[activeNode].text == "B") {
			pathFound = true;
			let backtraceIndex = tileArray.findIndex(findEnd);
			
			while (tileArray[tileArray[backtraceIndex].entryPoint].name != nameOfA) {
				path.unshift(tileArray[backtraceIndex].entryPoint);
				tileArray[tileArray[backtraceIndex].entryPoint].state = 4;
				tileArray[tileArray[backtraceIndex].entryPoint].updateState();
				backtraceIndex = tileArray[backtraceIndex].entryPoint;
			}
			
            break mapperLoop;
        }

        // berechne für diesen alle neighbors
        frontierList[activeNode].checkForNeighbors();

        // Füge Neighbors des aktuellen Knotens der Frontierlist hinzu
        for (var i = 0; i < frontierList[activeNode].neighbors.length; i++) {

            let distanceTravelled = frontierList[activeNode].distanceTravelled + frontierList[activeNode].neighborsDistance[i];
            if (containsObject(frontierList[activeNode].neighbors[i], frontierList)) {
                if (distanceTravelled < frontierList[activeNode].neighbors[i].distanceTravelled) {
                    frontierList[activeNode].neighbors[i].distanceTravelled = distanceTravelled;
                    frontierList[activeNode].neighbors[i].wayPointUsefulness = frontierList[activeNode].neighbors[i].distanceTravelled + frontierList[activeNode].neighbors[i].estimatedWayToB();
                    frontierList[activeNode].neighbors[i].entryPoint = frontierList[activeNode].name;
                }
            } else if (containsObject(frontierList[activeNode].neighbors[i], mappedList)) {
                continue;
            } else {
                frontierList[activeNode].neighbors[i].distanceTravelled = frontierList[activeNode].distanceTravelled + frontierList[activeNode].neighborsDistance[i];
                frontierList[activeNode].neighbors[i].wayPointUsefulness = frontierList[activeNode].neighbors[i].distanceTravelled + frontierList[activeNode].neighbors[i].estimatedWayToB();
                frontierList[activeNode].neighbors[i].entryPoint = frontierList[activeNode].name;
                frontierList.push(frontierList[activeNode].neighbors[i]);
				if (frontierList[activeNode].neighbors[i].text != "B") {
					frontierList[activeNode].neighbors[i].state = 3;
					frontierList[activeNode].neighbors[i].updateState();
				}
            }
        };

        // Füge den aktiven Knoten der mappedList hinzu und Lösche den aktven Knoten aus der frontierList
        mappedList.push(frontierList[activeNode]);
        frontierList.splice(activeNode,1);
	
	}
	
	clearNodes();
}
	
function clearNodes() {
	tileArray.forEach(function(element) {
		element.neighbors.length = 0;
		element.distanceTravelled = "";
		element.wayPointUsefulness = "";
		element.entryPoint = "";
	});
}
	
function containsObject(obj, list) {
    var i;
    for (i = 0; i < list.length; i++) {
        if (list[i] === obj) {
            return true;
        }
    }

    return false;
}
	
</script>
</body>

</html>